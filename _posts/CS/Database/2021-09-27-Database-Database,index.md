---
title: "Database : Database, Index"
excerpt_separator: <!--more-->
categories:
  - CS(Computer Science)
  - Database
tags:
  - CS(Computer Science)
  - Database 
  - "Database : Index"
toc: true
toc_sticky: true
toc_label: 목차
---

# Database

Database가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였습니다.(현재도 부분적으로 사용되고 있습니다.) Database는 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 합니다.





## Database의 기본개념

- 데이터의 집합 (a Set of Data)
- 여러 프로그램들의 통합된 정보들을 저장하고 운영할 수 있는 공용 데이터의 집합
- 효율적으로 저장, 검색, 갱신할 수 있도록 데이터 집합들끼리 연관시키고 조직화





## Database의 특성

- **실시간 접근성(Real-time Accessability)** : 사용자의 요구를 즉시 처리
- **계속적인 변화(Continuous Evolution)** : 정확한 값을 유지하려고 삽입·삭제·수정 작업 등을 이용해 데이터를 지속적으로 갱신
- **동시 공유성(Concurrent Sharing)** : 사용자마다 서로 다른 목적으로 사용하므로 동시에 여러 사람이 동일한 데이터에 접근하고 이용
- **내용 참조(Content Reference)** : 저장한 데이터 레코드의 위치나 주소가 아닌 사용자가 요구하는 데이터의 내용, 즉 데이터 값에 따라 참조





## DBMS(DataBase Management System)

다수의 사용자가 데이터베이스 내의 데이터에 접근할 수 있도록 해주는 소프트웨어입니다. DMBS가 등장하기 이전에는 개발자들이 파일의 데이터를 저장하고 읽어들이는 등의 기능을 모두 구현해야 했습니다. 이러한 불편함을 해결하기 위한 여러 가지 노력의 결과로 DMBS라는 소프트웨어가 등장하게 되었습니다.

DBMS에 대한 최초의 개념은 IBM에서 논문으로 나왔고 최초의 구현은 Oracle에서 하였습니다.



### DBMS의 특징

1. **데이터의 독립성**
   
   - **물리적 독립성** : Database 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없습니다.
   - 논리적 독립성 : Database는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족시켜줄 수 있습니다.
   
2. **데이터의 무결성** 

   여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 됩니다.

3. **데이터의 보안성**

    인가된 사용자들만 Database나 Database 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있습니다.

4. **데이터의 일관성**

    연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있습니다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있습니다.

5. **데이터 중복 최소화**

    Database는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있습니다.





## Database의 종류

Database는 1960년대에 시작된 이후 계층 및 Network Database로 시작하여 1980년대에 객체 지향 Database를 거쳐 오늘 날에는 SQL 및 NoSQL Database와 Cloud Database로 발전해 왔습니다.



### Relational(관계형) Database

**미리 정의된 범주에 맞는 데이터가 있는 테이블 집합으로 구성**됩니다. `SQL(Structured Query Language)`은 관계형 데이터베이스에 대한 표준 사용자 및 응용 프로그램 인터페이스입니다. 관계형 데이터베이스는 확장하기 쉽고 모든 기존 응용 프로그램을 수정할 필요 없이 원래 데이터베이스 생성 후에 새 데이터 범주를 추가할 수 있습니다.



### Distributed(분산) Database

분산 데이터베이스는 데**이터베이스의 일부가 여러 물리적 위치에 저장되고 처리가 네트워크의 다른 지점 간에 분산되거나 복제되는 데이터베이스**입니다.

분산 데이터베이스는 동종 또는 이기종일 수 있습니다. 동종 분산 데이터베이스 시스템의 모든 물리적 위치에는 동일한 기본 하드웨어가 있으며 동일한 운영 체제 및 데이터베이스 응용 프로그램을 실행합니다. 이기종 분산 데이터베이스의 하드웨어, 운영 체제 또는 데이터베이스 응용 프로그램은 위치마다 다를 수 있습니다.



### Cloud(클라우드) Database

클라우드 데이터베이스는 `하이브리드 클라우드`, `퍼블릭 클라우드` 또는 `프라이빗 클라우드`에서 **가상화된 환경을 위해 최적화되거나 구축된 데이터베이스**입니다. 클라우드 데이터베이스는 사용량에 따라 스토리지 용량 및 대역폭 비용을 지불할 수 있는 기능과 같은 이점을 제공하며, 고가용성과 함께 온디맨드 확장성을 제공합니다.

클라우드 데이터베이스는 또한 기업이 SaaS(Software-as-a-Service) 배포에서 비즈니스 애플리케이션을 지원할 수 있는 기회를 제공합니다.

> **SaaS(Software-as-a-Service)** : 사용자에게 클라우드 서비스 제공업체가 관리하는 소프트웨어 애플리케이션을 제공하는 서비스를 말합니다.
>
> **퍼블릭 클라우드** : 일반적으로 최종 사용자가 소유하지 않은 IT 인프라에서 생성되는 클라우드 환경을 말합니다.(AWS, Google Cloud 등)
>
> **프라이빗 클라우드** : 단일 최종 사용자 또는 그룹의 전용 클라우드 환경으로, 실행 시 대개 해당 사용자 또는 그룹의 방화벽으로 보호됩니다. 완전히 독립적인 액세스 권한이 있는 단일 고객만 기반 IT 인프라를 독점적으로 사용하는 경우 이러한 모든 클라우드를 프라이빗 클라우드라고 정의합니다.
>
> **하이브리드 클라우드** : 단일 IT 환경처럼 보이지만, 실제로는 여러 환경이 LAN(Local Area Network), WAN(Wide Area Network), VPN(Virtual Private Network) 및/또는 API를 통해 연결된 형태입니다. (2개 이상의 퍼블릭 클라우드, 1개 이상의 프라이빗 클라우드 + 1개 이상의 퍼블릭 클라우드 ...)



### NoSQL Database

**NoSQL 데이터베이스는 대규모 분산 데이터 세트에 유용**합니다. NoSQL 데이터베이스는 관계형 데이터베이스가 해결하도록 구축되지 않은 빅 데이터 성능 문제에 효과적입니다. 조직이 클라우드의 여러 가상 서버에 저장된 데이터 또는 비정형 데이터의 큰 청크를 분석해야 할 때 가장 효과적입니다.



### Object-oriented(객체지향) Database

객체 지향 프로그래밍 언어를 사용하여 생성된 항목은 종종 관계형 데이터베이스에 저장되지만 객체 지향 데이터베이스는 이러한 항목에 적합합니다.

객체 지향 데이터베이스는 **작업보다는 객체, 논리보다는 데이터를 중심으로 구성**됩니다. 예를 들어, 관계형 데이터베이스의 멀티미디어 레코드는 영숫자 값과 달리 정의 가능한 데이터 객체일 수 있습니다.



### Graph(그래프) Database

그래프 지향 데이터베이스 또는 그래프 데이터베이스는 **그래프 이론을 사용하여 관계를 저장, 매핑 및 쿼리하는 NoSQL 데이터베이스 유형**입니다. 그래프 데이터베이스는 **기본적으로 노드와 에지의 모음으로, 각 노드는 엔터티를 나타내고 각 에지는 노드 간의 연결을 나타냅니다.**

그래프 데이터베이스는 상호 연결 분석을 위한 인기가 높아지고 있습니다. 예를 들어, 회사는 그래프 데이터베이스를 사용하여 소셜 미디어에서 고객에 대한 데이터를 마이닝할 수 있습니다.

그래프 데이터베이스는 종종 그래프 데이터베이스 분석을 위한 선언적 프로그래밍 언어 및 프로토콜인` SPARQL`을 사용합니다. SPARQL에는 SQL이 수행할 수 있는 모든 분석을 수행할 수 있는 기능이 있으며 의미론적 분석, 관계 검사에도 사용할 수 있습니다. 따라서 **구조화된 데이터와 구조화되지 않은 데이터가 모두 있는 데이터 세트에 대한 분석을 수행하는 데 유용**합니다. SPARQL을 사용하면 사용자가 관계형 데이터베이스에 저장된 정보는 물론 FOAF(friend-of-a-friend) 관계, PageRank 및 최단 경로에 대한 분석을 수행할 수 있습니다.

> **데이터 마이닝** : 데이터 안에서 체계적이고 자동적으로 통계적 규칙이나 패턴을 찾아내는 것
>
> **FOAF(friend-of-a-friend)** : 사람과 사람간의 관계(Relationship)를 의미적으로 표현하기 위한 RDF(웹상의 자원의 정보를 표현하기 위한 XML 규격) 명세
>
> **PageRank** : 페이지의 중요도를 웹페이지 간 연결관계에 기반을 두고 측정한 지표





## Database 용어

Database에서 사용하는 용어에 대하여 알아보겠습니다.



### 테이블(Table)

![table](https://user-images.githubusercontent.com/79291114/134829130-32c4b05a-112a-4eba-9807-44c2e264934c.png)

- 행과 열로 이루어진 데이터의 집합을 테이블
- 엑셀의 표와 유사한 모양
- 일반적인 Database에서는 행과 열만 있으면 테이블이라고 하지만, `관계형 Database`에서는 여기에 특별한 제약을 추가해서 `릴레이션(Relation)`이라고 부름
- 아래 조건을 충족하는 테이블만이 릴레이션이 될 수 있기 때문에 모든 릴레이션은 테이블이지만, 모든 테이블이 릴레이션인건 아님

1. 모든 값은 유일한 값을 가짐
2. 하나의 릴레이션에서 중복되는 행이 존재하면 안됨



#### 행(Row == Record == Tuple)

- 테이블을 구성하는 데이터들 중 가로로 묶은 데이터셋을 의미 (column 값의 조합)
- 일반적으로 행은 한 객체에 대한 정보를 가지고 있음
- 릴레이션에서 같은 값을 가질 수 없음
- 행의 수는 Cardinality라고 함



#### 열(Column == Attribute)

- 테이블을 구성하는 데이터들 중 세로로 묶은 데이터셋을 의미(단일 종류의 데이터)
- 특정 데이터 타입 및 크기를 가지고 있음
- 일반적으로 열은 그 테이블의 속성을 의미하며 열을 구성하는 값들은 같은 `도메인(Domain)`으로 되어 있음
- 열의 수는 Degree라고 함



#### 도메인(Domain)

- Database에서 필드(Field)에 채워질 수 있는 값의 집합(범위)
- 예를 들어, 도메인이 1에서 10사이의 정수인 속성의 필드에 11이나 -1처럼 도메인을 벗어나는 값 또는 "고양이"처럼 아예 자료형이 다른 값이 들어갈 수 없음



#### 필드(Field)

- 행과 열의 교차점으로 데이터를 포함할 수 있고, 없을 때는 NULL값을 가지고 있음





### 스키마(Schema)

- Database의 구조를 전반적으로 기술한 것을 말함
- 구체적으로 Database를 구성하는 데이터 레코드의 크기, 키의 정의, 레코드 간의 관계 등을 정의한 것을 말함
- 사용자의 관점에 따라 `외부 스키마`, `개념 스키마`, `내부 스키마`로 구분
- DBMS는 외부 스키마에 명세된 사용자의 요구를 개념 스키마 형태로 변환하고, 이를 다시 내부 스키마 형태로 변환



#### 외부 스키마

- 사용자의 입장에서 정의한 Database의 논리적 구조를 말함
- 데이터들을 어떤 형식, 구조, 화면을 통해 사용자에게 보여줄 것인가에 대한 명세를 말하며 하나의 Database에는 여러 개의 외부 스키마가 있을 수 있음
- 일반 사용자에게는 질의어를 이용해 DB를 쉽게 사용할 수 있도록 하고 응용 프로그래머는 언어를 사용해서 DB에 접근

사용 주체나 응용 프로그램에 따라서 같은 데이터가 같은 구조로 저장되어 있는 Database를 바라보는 관점이 다를 수 있습니다. 즉, SELECT 쿼리를 던졌을 때, 볼 수 있는 표를 외부 스키마의 대표적인 예라고 생각하면 됩니다. (하지만 외부 스키마가 조회된 결과값을 의미 하는 것은 아닙니다.)



#### 개념 스키마

- 조직체 전체를 관장하는 입장에서 DB를 정의한 스키마를 말합니다.
- DB에 대한 모든 논리적 구조를 기술하기 때문에 Database에 하나만 존재하며, 통상 스키마라고 하면 개념 스키마를 일컫는다.

DA가 설계한 DB 구조를 생각하면 됩니다. ERD(Entity Relationship Diagram)가 대표적인 예라고 할 수 있습니다.



#### 내부 스키마

- Database가 어떻게 저장 장치에 저장될 지에 대한 명세를 말합니다.
- 물리적인 저장 장치와 Database 간의 관계를 정의하므로 시스템 프로그래머나 시스템 설계자가 보는 관점의 스키마입니다.

DA가 아닌 오라클사의 Database 개발자 관점에서의 스키마라고 할 수 있습니다.





### 키(Key)

<img width="831" alt="key table" src="https://user-images.githubusercontent.com/79291114/134831518-fb6e1e53-b7f1-48ae-ad17-dd1aae1f3ba3.png" style="zoom:80%;" >

키는 검색, 정렬 시 Tuple을 구분할 때, 기준이 되는 Attribute를 말합니다.



#### 후보키(Candidate Key)

**Tuple을 유일하게 식별하기 위해 사용하는 Attribute의 부분 집합**을 말합니다. 즉, 기본키로 사용할 수 있는 속성들을 말합니다. 아래의 2가지 조건을 만족하여야 합니다.

- **유일성** : Key로 하나의 Tuple을 유일하게 식별할 수 있음
- **최소성** : 꼭 필요한 속성으로만 구성

모든 릴레이션은 반드시 하나 이상의 후보 키를 가져야 합니다. (기본키가 필수이기 때문)

<학생> 릴레이션에서 `학번`이나 `주민번호`는 다른 레코드를 유일하게 구별할 수 있는 기본키로 사용할 수 있으므로 후보키가 될 수 있습니다. 즉, 기본키가 될 수 있는 키들을 후보키라 하는 것입니다.



#### 기본키(Primary Key)

- **후보키 중 선택한 Key**를 말합니다.
- 한 릴레이션에서 기본키로 특정 튜플을 유일할게 구별할 수 있어야 합니다.
- NULL 값을 가질 수 없고, 중복될 수 없다는 특징이 있습니다.

<학생> 릴레이션에는 `학번`이나 `주민 번호`가 기본키가 될 수 있고, <수강> 릴레이션에는 `학번+과목명`으로 조합해야 기본키가 만들어질 수 있습니다.  <수강> 릴레이션에서는 `학번` 속성과 `과목명` 속성은 개별적으로 기본키로 사용할 수 없습니다. 다른 튜플들과 구별되지 않기 때문입니다.



#### 대체키( == 보조키, Alternate Key)

후보키 둘 이상일 때, **기본키를 제외한 나머지 키**를 말합니다.

<학생> 릴레이션에서 `학번`을 기본키로 정하면 `주민번호`는 대체키가 됩니다.



#### 슈퍼키(Super Key)

- 한 릴레이션 내에 있는 **속성들의 집합으로 구성된 키**로서 릴레이션을 구성하는 모든 튜플 중 슈퍼키로 구성된 속성의 집합과 동일한 값을 나타내지 않습니다.
- 유일성은 만족하지만, 최소성은 만족하지 못하는 키를 말합니다.

<학생> 릴레이션에서는 `학번`, `주민번호`, `학번+주민번호`, `학번+주민번호+성명` 등으로 슈퍼키를 구성할 수 있습니다. 

또한, 여기서 최소성을 만족시키지 못한다는 말은 `학번+주민번호+성명`이 슈퍼키인 경우, 3개의 속성 조합을 통해 다른 튜플과 구별이 가능하지만, `성명` 단독적으로 슈퍼키를 사용했을 때는 구별이 가능하지 않기 때문에 최소성을 만족시키지 못하는 것입니다.



#### 외래키(Foreign key)

- 관계(Relation)를 맺고 있는 릴레이션 R1,R2에서 **릴레이션 R1이 참조하고 있는 릴레이션 R2의 기본키와 같은 R1 릴레이션의 속성**을 외래키라고 합니다. 
- 외래키는 참조되는 릴레이션의 기본키와 대응되어 **릴레이션 간에 참조 관계를 표현**하는 데 중요한 도구로 사용된다.
- 외래키로 지정되면 참조 테이블의 기본키에 없는 값은 입력할 수 없습니다.

<수강> 릴레이션이 <학생> 릴레이션을 참조하고 있으므로, <학생> 릴레이션의 `학번`은 기본키이고, <수강> 릴레이션의 `학번`은 외래키입니다. 즉, 각 릴레이션의 입장에서 속성은 기본키가 되기도 하고, 외래키가 되기도 합니다.





## Database의 성능?

`Database`의 **성능 이슈는 `디스크 I/O` 를 어떻게 줄이느냐에서 시작**됩니다. `디스크 I/O` 란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미합니다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정됩니다. 즉 **디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정**된다고 볼 수 있습니다.

그렇기 때문에 `순차 I/O` 가 `랜덤 I/O` 보다 빠를 수 밖에 없습니다. 하지만 현실에서는 대부분의 I/O 작업이 `랜덤 I/O` 입니다. `랜덤 I/O` 를 `순차 I/O` 로 바꿔서 실행할 수는 없을까? 라는 생각에서부터 시작되는 `Database 쿼리 튜닝`은 `랜덤 I/O` 자체를 줄여주는 것이 목적이라고 할 수  있습니다.



## Index

### 인덱스(Index)란?

`인덱스`는 말 그대로 **책의 맨 처음 또는 맨 마지막에 있는 색인**이라고 할 수 있습니다. 이 비유를 그대로 가져와서 인덱스를 살펴본다면 **데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호**가 될 것입니다. `DBMS` 도 Database 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸립니다. 그래서 **칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것**입니다.

**`DBMS` 의 인덱스는 항상 정렬된 상태를 유지**하기 때문에 원하는 **값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.** 결론적으로 `DBMS` 에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능입니다. `SELECT` 쿼리 문장의 `WHERE` 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있습니다.

### Index 자료구조

그렇다면 `DBMS` 는 인덱스를 어떻게 관리하고 있을까요?

#### B+-Tree 인덱스 알고리즘

일반적으로 사용되는 인덱스 알고리즘은 `B+-Tree` 알고리즘입니다. B+-Tree 인덱스는 **칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리합니다.) 원래의 값을 이용해 인덱싱하는 알고리즘입**니다.

[B+-Tree 인덱스 알고리즘에 대한 자세한 설명](https://zorba91.tistory.com/293)

#### Hash 인덱스 알고리즘

**칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘**으로 매우 빠른 검색을 지원합니다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 전방 일치와 같이 **값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없습니다.** 주로 메모리 기반의 Database에서 많이 사용합니다.

#### 왜 index 를 생성하는데 b-tree 를 사용할까요?

데이터에 접근하는 시간복잡도가 `O(1)`인 `hash table` 이 더 효율적일 것 같은데? SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 됩니다. **`hash table` 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생**합니다. 동등 연산(=)에 특화된 `hashtable`은 Database의 자료구조로 적합하지 않습니다.



### Primary Index vs Secondary Index

`클러스터(Cluster)`란 **여러 개를 하나로 묶는다는 의미로 주로 사용**되는데, `클러스터드 인덱스`도 크게 다르지 않습니다. `인덱스`에서 `클러스터드`는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것입니다. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말합니다.

`클러스터드 인덱스`는 테이블의 `프라이머리 키`에 대해서만 적용되는 내용입니다. 즉 **`프라이머리 키` 값이 비슷한 레코드끼리 묶어서 저장하는 것을 `클러스터드 인덱스`라고 표현**합니다. `클러스터드 인덱스`에서는 **`프라이머리 키` 값에 의해 레코드의 저장 위치가 결정(프라이머리 키로 정렬되기 때문에)**되며 `프라이머리 키` 값이 변경되면 그 레코드의 물리적인 저장 위치(테이블에서 레코드의 위치를 말합니다.) 또한 변경되어야 합니다. 그렇기 때문에 `프라이머리 키`를 신중하게 결정하고 `클러스터드 인덱스`를 사용해야 합니다.

`클러스터드 인덱스`는 테이블 당 한 개만 생성할 수 있습니다. `프라이머리 키`에 대해서만 적용되기 때문입니다, 이에 반해 `non 클러스터드 인덱스`는 테이블 당 여러 개를 생성할 수 있습니다.



### 결합인덱스(Composite Index)

인덱스로 설정하는 필드의 속성이 중요합니다. title, author 이 순서로 인덱스를 설정한다면 title 을 search 하는 경우, index 를 생성한 효과를 볼 수 있지만, author 만으로 search 하는 경우, index 를 생성한 것이 소용이 없어집니다. 따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 됩니다.



### Index 의 성능과 고려해야할 사항

SELECT 쿼리의 성능을 월등히 향상시키는 `INDEX`는 항상 좋은 것일까요? 쿼리문의 성능을 향상시킨다는데, 모든 컬럼에 `INDEX` 를 생성해두면 빨라지지 않을까요? *결론부터 말하자면 그렇지 않습니다.* 우선, 첫번째 이유는 `INDEX` 를 생성하게 되면 `INSERT`, `DELETE`, `UPDATE` 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생합니다. `INSERT` 의 경우 `INDEX` 에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따릅니다. `DELETE` 의 경우 `INDEX` 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 됩니다. 즉 row 의 수는 그대로인 것입니다. 이 작업이 반복되면 어떻게 될까요?

실제 데이터는 10 만건인데 데이터가 100 만건 있는 결과를 낳을 수도 있는 것입니다. 이렇게 되면 인덱스는 더 이상 제 역할을 못하게 되는 것입니다. `UPDATE` 의 경우는 `INSERT` 의 경우, `DELETE` 의 경우의 문제점을 동시에 수반합니다. 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문입니다. 즉 변경 전 데이터는 삭제되지 않고 `INSERT`로 인한 split 도 발생하게 됩니다.

하지만 더 중요한 것은 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것입니다. 즉, 데이터의 형식에 따라 인덱스를 만들면 효율적이고, 만들면 비효율적인 데이터의 형식이 존재한다는 것입니다. 어떤 경우에 그럴까요?

`이름`, `나이`, `성별` 세 가지의 필드를 갖고 있는 테이블을 생각해봅니다. `이름`은 온갖 경우의 수가 존재할 것이며 `나이`는 INT 타입을 갖을 것이고, 성별은 남, 녀 두 가지 경우에 대해서만 데이터가 존재할 것임을 쉽게 예측할 수 있습니다. 이 경우 어떤 컬럼에 대해서 인덱스를 생성하는 것이 효율적일까요? 결론부터 말하자면 이름에 대해서만 인덱스를 생성하는게 효율적입니다.

왜 성별이나 나이는 인덱스를 생성하면 비효율적일까요? 10000 레코드에 해당하는 테이블에 대해서 2000 단위로 성별에 인덱스를 생성했다고 가정해보면, 값의 range 가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O 가 발생하기 때문에 그 만큼 비효율적인 것입니다. (특정한 레코드를 찾을 때 범위가 작기 때문에 인덱스를 여러번 들러야 해서 그런 것 같습니다.)



---

참고 : [https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database)

[https://github.com/WooVictory/Ready-For-Tech-Interview](https://github.com/WooVictory/Ready-For-Tech-Interview)

[https://gyoogle.dev/blog/](https://gyoogle.dev/blog/)

[https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md](https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md)

[https://coding-factory.tistory.com/77](https://coding-factory.tistory.com/77)

[https://raisonde.tistory.com/entry/%EC%8B%9C%ED%97%98%EB%8C%80%EB%B9%84-%EC%99%B8%EB%B6%80-%EC%8A%A4%ED%82%A4%EB%A7%88-%EA%B0%9C%EB%85%90-%EC%8A%A4%ED%82%A4%EB%A7%88-%EB%82%B4%EB%B6%80-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%98%EC%9E%90](https://raisonde.tistory.com/entry/%EC%8B%9C%ED%97%98%EB%8C%80%EB%B9%84-%EC%99%B8%EB%B6%80-%EC%8A%A4%ED%82%A4%EB%A7%88-%EA%B0%9C%EB%85%90-%EC%8A%A4%ED%82%A4%EB%A7%88-%EB%82%B4%EB%B6%80-%EC%8A%A4%ED%82%A4%EB%A7%88%EB%A5%BC-%EA%B5%AC%EB%B6%84%ED%95%98%EC%9E%90)

[https://searchdatamanagement.techtarget.com/definition/database](https://searchdatamanagement.techtarget.com/definition/database)

[https://www.redhat.com/ko/topics/cloud-computing/public-cloud-vs-private-cloud-and-hybrid-cloud](https://www.redhat.com/ko/topics/cloud-computing/public-cloud-vs-private-cloud-and-hybrid-cloud)
