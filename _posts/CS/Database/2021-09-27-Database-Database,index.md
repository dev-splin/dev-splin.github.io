---
title: "Database : Database, Index"
excerpt_separator: <!--more-->
categories:
  - CS(Computer Science)
  - Database
tags:
  - CS(Computer Science)
  - Database 
  - "Database : Index"
toc: true
toc_sticky: true
toc_label: 목차
---

# Database

`데이터베이스`가 존재하기 이전에는 파일 시스템을 이용하여 데이터를 관리하였습니다.(현재도 부분적으로 사용되고 있습니다.) 데이터베이스는 데이터를 각각의 파일 단위로 저장하며 이러한 일들을 처리하기 위한 독립적인 애플리케이션과 상호 연동이 되어야 합니다.



## 데이터베이스의 기본개념

- 데이터의 집합 (a Set of Data)
- 여러 프로그램들의 통합된 정보들을 저장하고 운영할 수 있는 공용 데이터의 집합
- 효율적으로 저장, 검색, 갱신할 수 있도록 데이터 집합들끼리 연관시키고 조직화



## 데이터베이스의 특성

- **실시간 접근성(Real-time Accessability)** : 사용자의 요구를 즉시 처리
- **계속적인 변화(Continuous Evolution)** : 정확한 값을 유지하려고 삽입·삭제·수정 작업 등을 이용해 데이터를 지속적으로 갱신
- **동시 공유성(Concurrent Sharing)** : 사용자마다 서로 다른 목적으로 사용하므로 동시에 여러 사람이 동일한 데이터에 접근하고 이용
- **내용 참조(Content Reference)** : 저장한 데이터 레코드의 위치나 주소가 아닌 사용자가 요구하는 데이터의 내용, 즉 데이터 값에 따라 참조



## 데이터베이스의 특징

1. **데이터의 독립성**
   
   - **물리적 독립성** : 데이터베이스 사이즈를 늘리거나 성능 향상을 위해 데이터 파일을 늘리거나 새롭게 추가하더라도 관련된 응용 프로그램을 수정할 필요가 없습니다.
   - 논리적 독립성 : 데이터베이스는 논리적인 구조로 다양항 응용 프로그램의 논리적 요구를 만족시켜줄 수 있습니다.
   
2. **데이터의 무결성** 

   여러 경로를 통해 잘못된 데이터가 발생하는 경우의 수를 방지하는 기능으로 데이터의 유효성 검사를 통해 데이터의 무결성을 구현하게 됩니다.

3. **데이터의 보안성**

    인가된 사용자들만 데이터베이스나 데이터베이스 내의 자원에 접근할 수 있도록 계정 관리 또는 접근 권한을 설정함으로써 모든 데이터에 보안을 구현할 수 있습니다.

4. **데이터의 일관성**

    연관된 정보를 논리적인 구조로 관리함으로써 어떤 하나의 데이터만 변경했을 경우 발생할 수 있는 데이터의 불일치성을 배제할 수 있습니다. 또한 작업 중 일부 데이터만 변경되어 나머지 데이터와 일치하지 않는 경우의 수를 배제할 수 있습니다.

5. **데이터 중복 최소화**

    데이터베이스는 데이터를 통합해서 관리함으로써 파일 시스템의 단점 중 하나인 자료의 중복과 데이터의 중복성 문제를 해결할 수 있습니다.



## 데이터베이스의 성능?

`데이터베이스`의 **성능 이슈는 `디스크 I/O` 를 어떻게 줄이느냐에서 시작**됩니다. `디스크 I/O` 란 디스크 드라이브의 플래터(원판)을 돌려서 읽어야 할 데이터가 저장된 위치로 디스크 헤더를 이동시킨 다음 데이터를 읽는 것을 의미합니다. 이 때 데이터를 읽는데 걸리는 시간은 디스크 헤더를 움직여서 읽고 쓸 위치로 옮기는 단계에서 결정됩니다. 즉 **디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한 번에 기록하느냐에 따라 결정**된다고 볼 수 있습니다.

그렇기 때문에 `순차 I/O` 가 `랜덤 I/O` 보다 빠를 수 밖에 없습니다. 하지만 현실에서는 대부분의 I/O 작업이 `랜덤 I/O` 입니다. `랜덤 I/O` 를 `순차 I/O` 로 바꿔서 실행할 수는 없을까? 라는 생각에서부터 시작되는 `데이터베이스 쿼리 튜닝`은 `랜덤 I/O` 자체를 줄여주는 것이 목적이라고 할 수  있습니다.



## Index

### 인덱스(Index)란?

`인덱스`는 말 그대로 **책의 맨 처음 또는 맨 마지막에 있는 색인**이라고 할 수 있습니다. 이 비유를 그대로 가져와서 인덱스를 살펴본다면 **데이터는 책의 내용이고 데이터가 저장된 레코드의 주소는 인덱스 목록에 있는 페이지 번호**가 될 것입니다. `DBMS` 도 데이터베이스 테이블의 모든 데이터를 검색해서 원하는 결과를 가져 오려면 시간이 오래 걸립니다. 그래서 **칼럼의 값과 해당 레코드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것**입니다.

**`DBMS` 의 인덱스는 항상 정렬된 상태를 유지**하기 때문에 원하는 **값을 탐색하는데는 빠르지만 새로운 값을 추가하거나 삭제, 수정하는 경우에는 쿼리문 실행 속도가 느려집니다.** 결론적으로 `DBMS` 에서 인덱스는 데이터의 저장 성능을 희생하고 그 대신 데이터의 읽기 속도를 높이는 기능입니다. `SELECT` 쿼리 문장의 `WHERE` 조건절에 사용되는 칼럼이라고 전부 인덱스로 생성하면 데이터 저장 성능이 떨어지고 인덱스의 크기가 비대해져서 오히려 역효과만 불러올 수 있습니다.

### Index 자료구조

그렇다면 `DBMS` 는 인덱스를 어떻게 관리하고 있을까요?

#### B+-Tree 인덱스 알고리즘

일반적으로 사용되는 인덱스 알고리즘은 `B+-Tree` 알고리즘입니다. B+-Tree 인덱스는 **칼럼의 값을 변형하지 않고(사실 값의 앞부분만 잘라서 관리합니다.) 원래의 값을 이용해 인덱싱하는 알고리즘입**니다.

[B+-Tree 인덱스 알고리즘에 대한 자세한 설명](https://zorba91.tistory.com/293)

#### Hash 인덱스 알고리즘

**칼럼의 값으로 해시 값을 계산해서 인덱싱하는 알고리즘**으로 매우 빠른 검색을 지원합니다. 하지만 값을 변형해서 인덱싱하므로, 특정 문자로 시작하는 값으로 검색을 하는 전방 일치와 같이 **값의 일부만으로 검색하고자 할 때는 해시 인덱스를 사용할 수 없습니다.** 주로 메모리 기반의 데이터베이스에서 많이 사용합니다.

#### 왜 index 를 생성하는데 b-tree 를 사용할까요?

데이터에 접근하는 시간복잡도가 `O(1)`인 `hash table` 이 더 효율적일 것 같은데? SELECT 질의의 조건에는 부등호(<>) 연산도 포함이 됩니다. **`hash table` 을 사용하게 된다면 등호(=) 연산이 아닌 부등호 연산의 경우에 문제가 발생**합니다. 동등 연산(=)에 특화된 `hashtable`은 데이터베이스의 자료구조로 적합하지 않습니다.



### Primary Index vs Secondary Index

`클러스터(Cluster)`란 **여러 개를 하나로 묶는다는 의미로 주로 사용**되는데, `클러스터드 인덱스`도 크게 다르지 않습니다. `인덱스`에서 `클러스터드`는 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에서 착안된 것입니다. 여기서 비슷한 값들은 물리적으로 인접한 장소에 저장되어 있는 데이터들을 말합니다.

`클러스터드 인덱스`는 테이블의 `프라이머리 키`에 대해서만 적용되는 내용입니다. 즉 **`프라이머리 키` 값이 비슷한 레코드끼리 묶어서 저장하는 것을 `클러스터드 인덱스`라고 표현**합니다. `클러스터드 인덱스`에서는 **`프라이머리 키` 값에 의해 레코드의 저장 위치가 결정(프라이머리 키로 정렬되기 때문에)**되며 `프라이머리 키` 값이 변경되면 그 레코드의 물리적인 저장 위치(테이블에서 레코드의 위치를 말합니다.) 또한 변경되어야 합니다. 그렇기 때문에 `프라이머리 키`를 신중하게 결정하고 `클러스터드 인덱스`를 사용해야 합니다.

`클러스터드 인덱스`는 테이블 당 한 개만 생성할 수 있습니다. `프라이머리 키`에 대해서만 적용되기 때문입니다, 이에 반해 `non 클러스터드 인덱스`는 테이블 당 여러 개를 생성할 수 있습니다.



### 결합인덱스(Composite Index)

인덱스로 설정하는 필드의 속성이 중요합니다. title, author 이 순서로 인덱스를 설정한다면 title 을 search 하는 경우, index 를 생성한 효과를 볼 수 있지만, author 만으로 search 하는 경우, index 를 생성한 것이 소용이 없어집니다. 따라서 SELECT 질의를 어떻게 할 것인가가 인덱스를 어떻게 생성할 것인가에 대해 많은 영향을 끼치게 됩니다.



### Index 의 성능과 고려해야할 사항

SELECT 쿼리의 성능을 월등히 향상시키는 `INDEX`는 항상 좋은 것일까요? 쿼리문의 성능을 향상시킨다는데, 모든 컬럼에 `INDEX` 를 생성해두면 빨라지지 않을까요? *결론부터 말하자면 그렇지 않습니다.* 우선, 첫번째 이유는 `INDEX` 를 생성하게 되면 `INSERT`, `DELETE`, `UPDATE` 쿼리문을 실행할 때 별도의 과정이 추가적으로 발생합니다. `INSERT` 의 경우 `INDEX` 에 대한 데이터도 추가해야 하므로 그만큼 성능에 손실이 따릅니다. `DELETE` 의 경우 `INDEX` 에 존재하는 값은 삭제하지 않고 사용 안한다는 표시로 남게 됩니다. 즉 row 의 수는 그대로인 것입니다. 이 작업이 반복되면 어떻게 될까요?

실제 데이터는 10 만건인데 데이터가 100 만건 있는 결과를 낳을 수도 있는 것입니다. 이렇게 되면 인덱스는 더 이상 제 역할을 못하게 되는 것입니다. `UPDATE` 의 경우는 `INSERT` 의 경우, `DELETE` 의 경우의 문제점을 동시에 수반합니다. 이전 데이터가 삭제되고 그 자리에 새 데이터가 들어오는 개념이기 때문입니다. 즉 변경 전 데이터는 삭제되지 않고 `INSERT`로 인한 split 도 발생하게 됩니다.

하지만 더 중요한 것은 컬럼을 이루고 있는 데이터의 형식에 따라서 인덱스의 성능이 악영향을 미칠 수 있다는 것입니다. 즉, 데이터의 형식에 따라 인덱스를 만들면 효율적이고, 만들면 비효율적인 데이터의 형식이 존재한다는 것입니다. 어떤 경우에 그럴까요?

`이름`, `나이`, `성별` 세 가지의 필드를 갖고 있는 테이블을 생각해봅니다. `이름`은 온갖 경우의 수가 존재할 것이며 `나이`는 INT 타입을 갖을 것이고, 성별은 남, 녀 두 가지 경우에 대해서만 데이터가 존재할 것임을 쉽게 예측할 수 있습니다. 이 경우 어떤 컬럼에 대해서 인덱스를 생성하는 것이 효율적일까요? 결론부터 말하자면 이름에 대해서만 인덱스를 생성하는게 효율적입니다.

왜 성별이나 나이는 인덱스를 생성하면 비효율적일까요? 10000 레코드에 해당하는 테이블에 대해서 2000 단위로 성별에 인덱스를 생성했다고 가정해보면, 값의 range 가 적은 성별은 인덱스를 읽고 다시 한 번 디스크 I/O 가 발생하기 때문에 그 만큼 비효율적인 것입니다. (특정한 레코드를 찾을 때 범위가 작기 때문에 인덱스를 여러번 들러야 해서 그런 것 같습니다.)



---

참고 : [https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database](https://github.com/JaeYeopHan/Interview_Question_for_Beginner/tree/master/Database)

[https://github.com/WooVictory/Ready-For-Tech-Interview](https://github.com/WooVictory/Ready-For-Tech-Interview)

[https://gyoogle.dev/blog/](https://gyoogle.dev/blog/)

[https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md](https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md)

[https://coding-factory.tistory.com/77](https://coding-factory.tistory.com/77)

