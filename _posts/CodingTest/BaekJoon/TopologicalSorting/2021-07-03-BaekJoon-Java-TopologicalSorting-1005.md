---
title: "BaekJoon : 1005번(ACM Craft)"
excerpt_separator: <!--more-->
categories:
  - "Coding Test"
  - BaekJoon
tags:
  - "Coding Test"
  - BaekJoon
  - "BaekJoon : Topological Sorting"
toc: true
toc_sticky: true
toc_label: 목차
---

# Java : BaekJoon Topological Sorting

BaekJoon `Topological Sorting`(위상 정렬)  저의 문제풀이 입니다. <br>핵심 부분은 **Bold**해 놓겠습니다!

혹시 더 좋은 방법 알려주신다면 정말 감사하겠습니다! 



## 1005번(ACM Craft)

서기 2012년! 드디어 2년간 수많은 국민들을 기다리게 한 게임 ACM Craft (Association of Construction Manager Craft)가 발매되었다.

이 게임은 지금까지 나온 게임들과는 다르게 ACM크래프트는 다이나믹한 게임 진행을 위해 건물을 짓는 순서가 정해져 있지 않다. 즉, 첫 번째 게임과 두 번째 게임이 건물을 짓는 순서가 다를 수도 있다. 매 게임시작 시 건물을 짓는 순서가 주어진다. 또한 모든 건물은 각각 건설을 시작하여 완성이 될 때까지 Delay가 존재한다.

 

![img](https://www.acmicpc.net/upload/201003/star.JPG)

위의 예시를 보자.

이번 게임에서는 다음과 같이 건설 순서 규칙이 주어졌다. **1번 건물의 건설이 완료된다면 2번과 3번의 건설을 시작**할수 있다. (**동시에 진행이 가능**하다) 그리고 4**번 건물을 짓기 위해서는 2번과 3번 건물이 모두 건설 완료**되어야지만 4번건물의 건설을 시작할수 있다.

따라서 4**번건물의 건설을 완료하기 위해서는 우선 처음 1번 건물을 건설하는데 10초가 소요**된다. 그리고 **2번 건물과 3번 건물을 동시에 건설하기 시작하면 2번은 1초뒤에 건설이 완료되지만 아직 3번 건물이 완료되지 않았으므로 4번 건물을 건설할 수 없다.** **3번 건물이 완성되고 나면 그때 4번 건물을 지을수 있으므로 4번 건물이 완성되기까지는 총 120초가 소요**된다.

프로게이머 최백준은 애인과의 데이트 비용을 마련하기 위해 서강대학교배 ACM크래프트 대회에 참가했다! 최백준은 화려한 컨트롤 실력을 가지고 있기 때문에 모든 경기에서 특정 건물만 짓는다면 무조건 게임에서 이길 수 있다. 그러나 매 게임마다 특정건물을 짓기 위한 순서가 달라지므로 최백준은 좌절하고 있었다. 백준이를 위해 **특정건물을 가장 빨리 지을 때까지 걸리는 최소시간을 알아내는 프로그램을 작성**해주자.



### 입력

**첫째 줄에는 테스트케이스의 개수 T**가 주어진다. 각 테스트 케이스는 다음과 같이 주어진다. **첫째 줄에 건물의 개수 N 과 건물간의 건설순서규칙의 총 개수 K**이 주어진다. (건물의 번호는 1번부터 N번까지 존재한다) 

**둘째 줄에는 각 건물당 건설에 걸리는 시간 D**가 공백을 사이로 주어진다. **셋째 줄부터 K+2줄까지 건설순서 X Y**가 주어진다. (**이는 건물 X를 지은 다음에 건물 Y를 짓는 것이 가능**하다는 의미이다) 

마지막 줄에는 백준이가 **승리하기 위해 건설해야 할 건물의 번호 W**가 주어진다.

```java
5		// 테스트 케이스(T) 입력
3 2		// 1번 째 테스트 케이스 시작 : 건물의 개수(N)과 건설규칙의 총 개수(K) 입력
1 2 3	// 각 건물 건설에 소요되는 시간(D) 입력
3 2		// 여기부터 
2 1		// 여기까지 건설 순서 입력(앞 번호의 건물 다음에 뒤 번호의 건물을 지을 수 있다는 의미)
1		// 건설해야할 건물의 번호(W) 입력
4 3		// 2번 째 테스트 케이스
5 5 5 5
1 2
1 3
2 3
4
5 10	// 3번 째 테스트 케이스
100000 99999 99997 99994 99990
4 5
3 5
3 4
2 5
2 4
2 3
1 5
1 4
1 3
1 2
4
4 3		// 4번 째 테스트 케이스
1 1 1 1
1 2
3 2
1 4
4
7 8		// 5번 째 테스트 케이스
0 0 0 0 0 0 0
1 2
1 3
2 4
3 4
4 5
4 6
5 7
6 7
7
```



### 출력

**건물 W를 건설완료 하는데 드는 최소 시간을 출력**한다. 편의상 건물을 짓는 명령을 내리는 데는 시간이 소요되지 않는다고 가정한다.

건설순서는 모든 건물이 건설 가능하도록 주어진다.

```java
6		// 테스트 케이스 개수만큼 건물 W를 건설하는데 소요되는 시간 출력
5
399990
2
0
```



### 제한

- 2 ≤ N ≤ 1000
- 1 ≤ K ≤ 100,000
- 1 ≤ X, Y, W ≤ N
- 0 ≤ D ≤ 100,000, D는 정수



### 위상 정렬

**위상 정렬은 순서가 정해져 있는 작업을 차례로 수행해야할 때 순서를 결정해주기 위해 사용하는 알고리즘** 입니다. 문제에서 건물을 건설하기 위한 순서가 설정되어 있기 때문에 위상 정렬을 사용해 문제를 해결할 수 있습니다.

위상 정렬은 시작점이 존재해야 하는데 사이클 그래프에서는 시작점부터 찾을 수가 없기 때문에 **사이클이 발생하는 경우 위상정렬을 사용할 수 없습니다.** 때문에 위상 정렬은 아래와 같은 결과를 도출할 수 있습니다.

1. 현재 그래프가 위상 정렬이 가능한지 (사이클 존재 유무)
2. 위상 정렬이 가능하다면 그 결과는 무엇 인지

위상 정렬은 Stack이나 Queue를 이용할 수 있는데 보통은 Queue를 많이 사용합니다. 더 자세한 설명은 참고 링크를 확인해 주세요!

**참고 링크**

[나동빈님의 위상 정렬 설명](https://blog.naver.com/ndb796/221236874984)



#### 실행 순서

위상 정렬은 순서가 정해져 있어야 하기 때문에 노드의 개수 만큼 배열을 만들고, X -> Y로 가는 간선이 있다고 가정하면 X다음 Y가 오므로 **배열[Y]에 Y로 오는 간선의 수(진입 차수)를 설정**해줍니다. 그 다음 아래와 같이 실행하게 됩니다.

1. 진입차수가 0인 정점을 Queue에 삽입합니다.
   - 처음 진입차수가 0이라는 것은 시작점 이라는 의미합니다. 이 때, 사이클이 발생하는 그래프라면 없을 수도 있습니다.
2. Queue에서 원소를 꺼내 연결된 모든 간선을 제거합니다.
   - Queue에서 X를 꺼낸다면 X에서 특정한 Y로 가는 간선을 제거합니다. 즉, 배열[Y]의 진입 차수를 줄여줍니다. (Y가 여러 개 일 수도 있습니다.)
3. 간선 제거 이후에 진입차수가 0이 된 정점을 Queue에 삽입합니다.
4. Queue가 빌 때까지 2번 ~ 3번 과정을 반복합니다.
   - 사이클 존재 유무를 파악해야하는 경우는 모든 원소를 방문하기 전에 Queue가 비어있는 경우입니다.
   - 모든 원소를 방문했다면 큐에서 꺼낸 순서가 위상 정렬의 결과입니다.



#### 문제 풀이

위의 실행 순서처럼 **진입 차수를 이용하기 위한 edges[]**와 **해당 인덱스의 건물을 건설하는데 까지 걸리는 시간을 저장하는 arrivalTime[]**를 이용해 문제를 해결할 수 있습니다. 이 때, **건설 순서는 이전 인덱스를 기준으로 저장해두어야 합니다. ex) 2 3이면 list[2]에 3을 넣어 놓습니다.**

arrivalTime[]의 값은 **현재 인덱스를 건설하는데 까지 걸리는 시간**과 **이전의 인덱스 건물을 건설하는데 까지의 시간에 현재 건물을 건설하는데 걸리는 시간을 더한 값 중 더 큰 값**으로 갱신해 주어야 합니다. 위의 예제 중 아래와 같은 3번째 테스트 케이스를 예시로 들어보겠습니다.

```java
// 3번 째 테스트 케이스
5 10	// 건물의 개수와 건설 순서 개수
100000 99999 99997 99994 99990	// 해당 인덱스 건물을 건설하는 데 걸리는 시간
4 5		// 여기 부터
3 5
3 4
2 5
2 4
2 3
1 5
1 4
1 3
1 2		// 여기 까지 건설 순서
4		// 건설해야 할 건물 번호
```

처음 입력을 마치게 되면 edges[]와 arrivalTime[]은 아래와 같게 됩니다.

|   배열 / 인덱스   |   1    |   2   |   3   |   4   |   5   |
| :---------------: | :----: | :---: | :---: | :---: | :---: |
|    **edges[]**    |   0    |   1   |   2   |   3   |   4   |
| **arrivalTime[]** | 100000 | 99999 | 99997 | 99994 | 99990 |

arrivalTime[]은 아직 갱신하지 않았기 때문에 해당 인덱스의 건설 시간만 들어가 있습니다. 이제 Queue에 진입 차수가 0인(edges[]의 값이 0인) 건물 번호를 넣으면서 계속 갱신을 해보겠습니다. 

`edges는 e, arrivalTime은 at, Queue는 q`로 나타내고 Queue와 배열의 값들은 `배열 이름 -> 인덱스의 값(왼쪽부터 순서대로)`로 나타내겠습니다.

1. `e -> 0,1,2,3,4` / `at -> 100000,99999,99997,99994,99990` / `q -> 1`
   - 위상 정렬 시작 (q에 1을 넣습니다.)
2. `e -> 0,0,1,2,3` / `at -> 100000,199999,199997,199994,199990` / `q -> 2`
   - q에서 1을 빼고 list[1]에 있는 인덱스(2,3,4,5)들을 확인하면서 at를 갱신하고, 진입 차수를 변경해주면서 진입 차수가 0이 된 2를 q에 넣습니다.
3. `e -> 0,0,0,1,2` / `at -> 100000,199999,299996,299993,299990` / `q -> 3`
   - q에서 2를 빼고 list[2]에 있는 인덱스(3,4,5)들을 확인하면서 at를 갱신하고, 진입 차수를 변경해주면서 진입 차수가 0이 된 3을 q에 넣습니다.
4. `e -> 0,0,0,0,1` / `at -> 100000,199999,299996,399990,399986` / `q -> 4`
   - q에서 3을 빼고 list[3]에 있는 인덱스(4,5)들을 확인하면서 at를 갱신하고, 진입 차수를 변경해주면서 진입 차수가 0이 된 4을 q에 넣습니다.
5. `e -> 0,0,0,0,0` / `at -> 100000,199999,299996,399990,499980` / `q -> 5`
   - q에서 4를 빼고 list[4]에 있는 인덱스(5)를 확인하면서 at를 갱신하고, 진입 차수를 변경해주면서 진입 차수가 0이 된 5를 q에 넣습니다.
6. `e -> 0,0,0,0,0` / `at -> 100000,199999,299996,399990,499980` / `q -> `
   - q에서 5를 빼고 list[5]를 확인하지만 list[5]는 값이 없기 때문에 q에 아무 것도 넣지 않고, q에 값이 없기 때문에 위상 정렬을 종료합니다.

위와 같이 위상 정렬을 완료하면 **at(arrivatlTime[])의 인덱스 값이 해당 인덱스 건물을 건설하는데 까지 걸리는 시간**이 됩니다.



### 코드

```java
import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Queue;
import java.util.StringTokenizer;

public class Main {
		
	public static void main(String[] args) {
		InputStreamReader isr = new InputStreamReader(System.in);
		BufferedReader br = new BufferedReader(isr);
		
		try {
			int t = Integer.parseInt(br.readLine());
			
			StringBuilder sb = new StringBuilder();
			
			// 입력 시작
			for (int i = 0; i < t; i++) {
				StringTokenizer stk = new StringTokenizer(br.readLine());
				
				int n = Integer.parseInt(stk.nextToken());
				int k = Integer.parseInt(stk.nextToken());
				
				// 건설 시간
				int times[] = new int[n+1];
				// 인덱스에 해당하는 건물을 만들기 위한 이전 건물 수
				// ex) edges[4]가 2라면, edges[4]가 0이 되어야 4번 건물을 건설할 수 있음
				int edges[] = new int[n+1];
				
				stk = new StringTokenizer(br.readLine());
				for (int j = 1; j <= n; j++)
					times[j] = Integer.parseInt(stk.nextToken());
				
				// 해당 인덱스를 건설한 다음 건설할 수 있는 건물을 저장
				List<Integer> list[] = new ArrayList[n+1];
				
				for (int j = 1; j <= n; j++)
					list[j] = new ArrayList<>();
				
				for (int j = 0; j < k; j++) {
					stk = new StringTokenizer(br.readLine());
					
					int x = Integer.parseInt(stk.nextToken());
					int y = Integer.parseInt(stk.nextToken());
					
					list[x].add(y);
					++edges[y];
				}
				
				// 목표 건물 설정
				int dst = Integer.parseInt(br.readLine());
				// 입력 종료
				
				// 건설할 수 있는(edges가 0인) 건물들을 넣을 큐
				Queue<Integer> q = new LinkedList<>();
				// 해당 인덱스의 건물을 건설하는데 까지 걸린 시간을 저장
				int arrivalTime[] = new int[n+1];
				
				// 해당 인덱스 건물의 건설시간을 미리 넣어주고, 처음에 건설할 수 있는(edges가 0인)건물을 큐에 넣음
				for (int j = 1; j <= n; j++) {
					arrivalTime[j] = times[j];
				
					if(edges[j] == 0) {
						q.add(j);
					}
				}
				
				while(!q.isEmpty()) {
					int curNum = q.poll();
					
					for(Integer num : list[curNum]) {
						// num에 해당하는 건물은 curNum에 해당하는 건물을 건설한 후 건설할 수 있기 때문에
						// curNum을 건설하기 까지의 시간(arrivalTime[curNum) + 현재 num을 건설하는 시간(times[num])과
						// 현재 num을 건설하기 까지(arrivalTime[num])의 시간 중 최대 값을 넣어줍니다.
						
						// 최대 값을 넣어주는 이유는 num을 건설하기 위해서는 먼저 건설해야하는 건물들이 모두 건설되어야 하기 때문입니다.
						// 예를 들어, 4번 건물을 건설하기 위해서 2번 건물(건설시간 1초)과 3번 건물(건설시간 100초)을 완료해야 한다면,
						// 2번 건물은 1초만에 건설이 끝났다고 하더라도 3번 건물이 건설 완료되어야 4번 건물을 건설할 수 있기 때문에
						// 결국 4번 건물을 건설하기 위해서는 2번 건물 건설(1초 소요)이 끝나고 3번 건물 건설(100초 소요)이 끝나야 합니다. (동시 진행 가능)
						arrivalTime[num] = Math.max(arrivalTime[num], arrivalTime[curNum] + times[num]);
						
						// 건설할 수 있는(edges가 0인)건물을 큐에 넣음
						if(--edges[num] == 0)
							q.add(num);
					}
				}
				
				sb.append(arrivalTime[dst]).append('\n');
			}
			
			System.out.println(sb.toString());
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

```



---

해당 코드들은 [저의 GitHub](https://github.com/dev-splin/Coding-Test)에서 확인할 수 있습니다.

