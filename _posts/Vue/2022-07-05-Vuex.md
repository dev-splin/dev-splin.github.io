---
title: "Vue : Vuex"
excerpt_separator: <!--more-->
categories:
  - Vue
tags:
  - Vue
  - "Vue : Vuex"
toc: true
toc_sticky: true
toc_label: 목차
---

# Vuex란?

- **Store**라고도 불림.
- 무수히 많은 컴포넌트의 데이터를 관리하기 위한 **상태 관리 패턴이자 라이브러리**
  - 서비스가 복잡해질수록 컴포넌트 간에 데이터 전달이 어려워지기 때문에 Vuex를 사용하는 것
- React의 **Flux 패턴에서 기인**함

> **Flux 패턴** ? 
>
> 기존 MVC 패턴은 Model과 View 간 양방향 통신이 가능합니다. 하지만 서비스가 커질 수록 이런 양방향 통신이 데이터의 흐름을 예측할 수 없게 만듭니다.
>
> 때문에 이런 단점을 극복하고자 데이터의 흐름이 여러 갈래로 나뉘지 않고 단방향으로만 처리하는 Flux 패턴이 나오게됩니다.





# Flow

Vuex의 Flow는 아래와 같이 이루어집니다.

- 컴포넌트 -> 비동기 로직 -> 동기 로직 -> 상태 변경





# 설치 및 등록

1. Vuex를 사용할 **프로젝트로 이동**
2. 터미널에서 **npm i vuex@3.6.2 --save** (2022.02.07 부터 이 명령어로 사용)
3. **store** 폴더 생성

> **store 폴더** ?
>
> Vuex 폴더는 **보통 store라는 이름**으로 만듭니다. 해당 폴더는 관행적으로 **프로젝트의 src 바로 아래에 store 폴더**를 만듭니다.

4. store 폴더에 **store.js** 생성
5. 아래의 세팅을 참고



## 세팅

### store.js

```javascript
import Vue from "vue";
import Vuex from "vuex";

Vue.use(Vuex);

export const store = new Vuex.Store({
    
});
```

**Vue.use()**는  Vue의 Plugin으로, **Vue를 사용하는 모든 영역에 특정 기능을 추가**할 때 사용합니다. 해당 세팅을 해주어야 다른 컴포넌트에서 **this.$store로 Vuex를 사용**할 수 있습니다.



### main.js

```javascript
import Vue from 'vue'
import App from './App.vue'
import {store} from "@/store/store";

Vue.config.productionTip = false

new Vue({
  store,
  render: h => h(App)
}).$mount('#app')
```

**main.js에 store(Vuex)를 등록**해주어야 합니다.





# 기능

### state

컴포넌트 간에 공유하는 데이터를 말합니다.  (Vue의 **data()**와 비슷) 아래와 같이 **store.js에서 데이터를 등록하여 사용**할 수 있습니다.



#### store.js (state 값 등록)

```javascript
const storage = {
    created() {
        const arr = [];
        if (localStorage.length > 0) {
            for (let i = 0; i < localStorage.length; i++) {
                const item = localStorage.getItem(localStorage.key(i));
                const parsedItem = JSON.parse(item);

                arr.push(parsedItem);
            }
        }

        return arr;
    },
}

export const store = new Vuex.Store({
    state: {
        todoItems : storage.created(),
    }
});
```



#### TodoList.vue (state 데이터 사용)

```vue
<template>
  <div>
    <transition-group name="list" tag="ul">
      <li v-for="(todoItem, index) in this.$store.state.todoItems" :key="todoItem.item" class="shadow">
        <i class="checkBtn fa-solid fa-check" :class="{checkBtnCompleted: todoItem.completed}" @click="toggleComplete(todoItem, index)"></i>
        <span :class="{textCompleted: todoItem.completed}">{{ todoItem.item }}</span>
        <span class="removeBtn" @click="removeTodo(todoItem.item, index)">
          <i class="fa-solid fa-trash-can"></i>
        </span>
      </li>
    </transition-group>
  </div>
</template>
```





---

### mutation

state 값을 변경하는 이벤트 로직이나 메서드를 말합니다.  (Vue의 **methods**와 비슷)

> **왜 state를 직접 변경하지 않고 mutations로 변경할까?**
>
> 여러 개의 컴포넌트에서 공유하는 데이터인 state 값을 그냥 변경해버리면, **어느 컴포넌트에서 해당 state를 변경했는지 추적하기가 어렵습니다.**
>
> 때문에 **Devtools로 반응성을 확인하고 테스트 할 수 있는 mutations를 이용하여 값을 변경**하는 것이 좋습니다.



#### store.js (mutation 메서드 등록)

**store의 mutations에 메서드를 등록**해주면 됩니다.
이 때, mutations에 등록한 **메서드의 첫 번째 인자는 state를, 두 번째 인자는 데이터 값**을 받을 수 있습니다. 때문에 state값을 조작할 수 있는 것입니다.

```javascript
export const store = new Vuex.Store({
    state: {
        todoItems : storage.created(),
    },
    mutations: {
        addOneItem(state, todoItem) {
            const obj = {completed: false, item: todoItem};
            localStorage.setItem(todoItem, JSON.stringify(obj));
            state.todoItems.push(obj);
        },
    }
});
```



#### TodoInput.vue (mutations 메서드 사용)

store의 **commit() 메서드로 mutation을 실행**시킬 수 있습니다.
**commit 메서드의 첫 번째 인자는 메서드 이름을, 두 번째는 데이터**를 넣을 수 있습니다. (만약 **여러 데이터를 넣어야 한다면 객체로 생성**하여 넣어주면 됩니다.)

```javascript
methods: {
    addTodo() {
      if(!this.validateItem()) {
        this.showModal = true;
        return;
      }

      this.$store.commit('addOneItem', this.newTodoItem);
      this.clearInput();
    },

	...

}
```





---

### action

비동기 처리 로직을 선언하는 메서드를 말합니다. (Vue의 **async methods**와 비슷)

> **왜 비동기 처리 로직은 actions에 선언해야 할까?**
>
> 비동기 로직은 시간 차가 있기 때문에 언제 **어느 컴포넌트에서 값이 조작되는지 확인하기가 어렵습니다.**
> **동기, 비동기 로직을 나누지 않으면 데이터를 확인하는데 큰 어려움**이 있기 때문에 actions에 비동기 로직을 모아 놓는 것입니다.



#### store.js (action 메서드 등록)

**store의 actions에 메서드를 등록**해주면 됩니다.
이 때, actions에 등록한 **메서드의 첫 번째 인자는 context**를 받을 수 있습니다. (context는 store에 있는 메서드와 속성에 접근할 수 있습니다.)

```javascript
export const store = new Vuex.Store({
    state: {
        product : '',
    },
    mutations: {
        setData(state, fetchedData) {
            state.product = fetchedData;
        }
    },    
    actions: {
        fetchProductData(context) {
            return axios.get('https://domain.com/products/1')
            			.then(response => context.commit('setData', response));
        }
    }
});
```



#### App.vue (actions 메서드 사용)

store의 **dispatch() 메서드로 actions을 실행**시킬 수 있습니다.
**dispatch 메서드의 첫 번째 인자는 메서드 이름**을 넣어 실행 시킬 수 있습니다.

```javascript
methods: {
    getProduct() {
     this.$store.dispatch('fetchProductData');
    }
}
```





---

### getters

연산된 state 값을 접근하는 속성을 말합니다. (Vue의 **computed**와 비슷)



### view

데이터를 표시하는 화면을 말합니다. (Vue의 **template**과 비슷)











---

참고 : [Vue.js 중급 강좌 - 웹앱 제작으로 배워보는 Vue.js, ES6, Vuex](https://www.inflearn.com/course/vue-pwa-vue-js-%EC%A4%91%EA%B8%89/dashboard)
